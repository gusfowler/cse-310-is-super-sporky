main.cpp:

#include "Graph.h"

using namespace std;

void getArrCityInfo(string& oneArrCityInfo, string& arrCityName, double& price);
City* searchCity(City* oneCityArray[],int size, string oneCityName);
bool cityExists(City* oneCityArray[], int arraySize, string oneCityName);

int main()
{
   //number of vertices and edges
int V, E;   

cin >> V >> E;
cin.ignore(20, '\n');

//a City array used to store all vertices (Cities) of the graph
City** cityArray = (City **)malloc(sizeof(City*)*V);

   //initalizes each City pointer in cityArray
   for (int i = 0; i < V; i++)
   {
       cityArray[i] = (City*)malloc(sizeof(City));
       cityArray[i] = NULL;
   }

//an array used to store all edges of the graph
Edge** edgeArray = (Edge**)malloc(sizeof(Edge*)*E);

   //initalizes each Edge pointer in edgeArray
   for (int j = 0; j < E; j++)
   {
       edgeArray[j] = (Edge*)malloc(sizeof(Edge));
       edgeArray[j] = NULL;
   }

   //index for cityArray and edgeArray
int i = 0, j = 0;

   //initalizes city pointers for user inputted inersetion
   //and edge insertion
   struct City* city1 = (City*)malloc(sizeof(City));
   struct City* city2 = (City*)malloc(sizeof(City));

   //gets depature and arrival string for each city
string oneLine;
getline(cin, oneLine);

while(oneLine.compare("End") != 0)
{
//gets one line of the input, extracts the depature
//city
       string delimiter = ",";
       int pos = oneLine.find(delimiter);
       string deptCity = oneLine.substr(0, pos);

       //checks if depature City already exists in CityArray
       bool exists = cityExists(cityArray, V, deptCity);

       // if found,returns pointer from CityArray
       if (exists == true)
       {
           city1 = searchCity(cityArray, V, deptCity);
       }
       //else, a new City object is made and inserted into
       //CityArray
       else
       {
           city1 = new City(deptCity);
           cityArray[i] = city1;
           i++;
       }
       oneLine.erase(0, pos + delimiter.length());

       while (!oneLine.empty())
       {
           if (oneLine.compare(",") != 0)
           {
               //extracts the arrival city info.
               string arrCity = " ";
               double price = 0.0;
               getArrCityInfo(oneLine, arrCity, price);

               //checks if arrival City already exists in cityArray
               bool exists = cityExists(cityArray, V, arrCity);

               // if found,returns pointer from CityArray
               if (exists == true)
               {
                   city2 = searchCity(cityArray, V, arrCity);
               }
               //else, a new City object is made and inserted into
       //CityArray
               else
               {
                   city2 = new City(arrCity);
                   cityArray[i] = city2;
                   i++;
               }

               //by using the two cities we got above, create a new edge, add
               //it inside edgeArray
               Edge* aNewEdge = (Edge*)malloc(sizeof(Edge));
               aNewEdge = new Edge(city1, city2, price);

               edgeArray[j] = aNewEdge;
               j++;
           }
           //no arrival cities exist in the line. The line is erased and
           //the next line is called
           else
           {
               oneLine.erase(0, oneLine.length());
           }
       }
//gets next line
getline(cin, oneLine);
} //repeat 'End' is found

   //creates new Graph object
   Graph flightPath = Graph(V, E, cityArray, edgeArray);

//Run Kruskal MST algorithm on graph
   flightPath.MST_Kruskal();

   //deconstructs Edges and Graph as
   //program finishes
   for (int i = 0; i < E; i++)
   {
       edgeArray[i]->~Edge();
   }
   flightPath.destructor();
}

//****************************************************************
//By giving a string, for example 'Dallas(456.5)', this function
//extracts the contents and stores the arrival info (city
//name and price) into variables to be used in City and Edge object
//****************************************************************
void getArrCityInfo(string& oneArrCityInfo, string& arrCityName, double& price)
{
//extracts city name
string delimiter1 = "(", delimiter2 = ")";
int pos=oneArrCityInfo.find(delimiter1);
string token = oneArrCityInfo.substr(0,pos);
arrCityName = token;

//erases city names form String
oneArrCityInfo.erase(0, pos+delimiter1.length());

//extracts and erases flight price from String
pos = oneArrCityInfo.find(delimiter2);
token = oneArrCityInfo.substr(0,pos);
price = stod(token);
oneArrCityInfo.erase(0, pos + delimiter2.length() + 1);
}

//*********************************************************************
//By giving a string, for example 'Dallas(456.5)', this function
//searches the CityArray for an instance of that name. Returns
//'true' if city name is found in list
//****************************************************************
bool cityExists(City* oneCityArray[], int arraySize, string oneCityName)
{
   //returns false if list is empty
   if (oneCityArray[0] == NULL)
   {
       return false;
   }

   //searches cityArray for City with given name
   for (int i = 0; i < arraySize; i++)
   {
       if (oneCityArray[i] != NULL)
       {
           //returns true if found
           if (oneCityArray[i]->cityName == oneCityName)
           {
               return true;
           }
       }
   }
   //else returns false
   return   false;
}

//*********************************************************************
//Given a city name, this function searches cityArray and it return a
//pointer points to the City if it already exists, otherwise it returns NULL
//****************************************************************
City* searchCity(City* oneCityArray[], int arraySize, string oneCityName)
{
   //searches cityArray for City with given name
   for (int i = 0; i < arraySize; i++)
   {
       //returns ponter to city if found
       if (oneCityArray[i]->cityName == oneCityName)
       {
           return oneCityArray[i];
       }
   }
   //else returns NULL
   return   NULL;
}

Graph.h:

#include "Edge.h"

using namespace std;

class Graph
{
private:
int V, E; //number of vertices and edges in the graph
City** setOfCities; //an array of cities
Edge** setOfEdges; //an array of edges

public:
Graph(int numOfCities, int numOfEdges, City* cityArray[], Edge* edgeArray[]);
void destructor();
void make_set(City* aCity);
City* find_set(City* aCity);
void link(City* aCity, City* bCity);
void Union(City* aCity, City* bCity);
void printEdgeArray();
void MergeSortEdges();
void mergeSort(Edge* edgeArray[], int start, int end);
void merge(Edge* edgeArray[], int start, int mid, int end);

void MST_Kruskal();
};

//*******************************************************************
//Constructor
Graph::Graph(int numOfCities, int numOfEdges, City* cityArray[], Edge* edgeArray[])
{
   this->V = numOfCities;
   this->E = numOfEdges;
   setOfCities = cityArray;
   setOfEdges = edgeArray;
}

//*******************************************************************
//Destructor
void Graph::destructor()
{
   for (int i = 0; i < E; i++)
   {
       setOfEdges[i]->~Edge();
   }
}

//*******************************************************************
//Given a City, this function creates a new set whose only member is
//the City.
//*******************************************************************
void Graph::make_set(City* aCity)
{
   aCity->parent = aCity;
   aCity->rank = 0;
}

//*******************************************************************
//Given a City, this function returns a pointer to the representative
//of the (unique) set containing 'aCity
//*******************************************************************
City* Graph::find_set(City* aCity)
{
   //if the city is not the representative of the set,
//find_set is recursed until the reprsentative is found
   if ((aCity->cityName) != (aCity->parent->cityName))
   {
       aCity->parent = find_set(aCity->parent);
   }
   return aCity->parent;
}

//*******************************************************************
//Given two cities, this function checks the dynamic sets that contain
//'aCity' and 'bCity' and update their rank and parent info. accordingly
//*******************************************************************
void Graph::link(City* aCity, City* bCity)
{
   //if cities are disjoint, the alpahabetcially
   //higher vertex is combined with the lower
   //vertex
   if ((aCity->cityName) != (bCity->cityName))
   {
       if ((aCity->cityName) > (bCity->cityName))
       {
           bCity->parent = aCity;
       }
       else
       {
           aCity->parent = bCity;
           //rank increases to keep balance
           if ((aCity->cityName) < (bCity->cityName))
           {
               bCity->rank = bCity->rank +1;
           }
       }
   }
}

//*******************************************************************
//Given two cities, this function unites the dynamic sets that contain
//'aCity' and 'bCity' into a new set that is the union of the two sets.
//*******************************************************************
void Graph::Union(City* aCity, City* bCity)
{
   link(find_set(aCity), find_set(bCity));
}

//*******************************************************************
//This function print each of the edges of edge array. It can be
//used as an auxillary function to check the MergeSort result
//*******************************************************************
void Graph::printEdgeArray()
{
   for (int i = 0; i < E; i++)
   {
       setOfEdges[i]->printEdge();
   }
}

//*******************************************************************
//This function performs the Merge Sort on the graph edges according
//to the weight. Sort all edges in non-decreasing order
//*******************************************************************
void Graph::MergeSortEdges()
{
   mergeSort(setOfEdges, 0, E-1);
}

//*******************************************************************
//This function performs the Merge Sort on a sub edgeArray.
//*********************************************************************
void Graph::mergeSort(Edge* edgeArray[], int start, int end)
{
   if (start < end)
   {
       //middle values of edgeArray
       int mid = start + (end - start) / 2;

       //splits edgeArray into two subproblems
       mergeSort(edgeArray, start, mid);
       mergeSort(edgeArray, mid + 1, end);

       //merges two sorted subproblems
       merge(edgeArray, start,mid,end);
   }
}

//*******************************************************************
//This function merges the two sorted sub edgeArray.
//*******************************************************************
void Graph::merge(Edge* edgeArray[], int start, int mid, int end)
{

//get the length of the first half subarray
int n1 = mid-start+1;
//get the length of the second half subarray
int n2 = end-mid;

//Dynamically create two new arrays each stored the sorted half
Edge** left = (Edge **)malloc(sizeof(Edge*) * n1);
Edge** right = (Edge**)malloc(sizeof(Edge*) * n2);
  
//initalizes Edges both subarrays
for (int i = 0; i < n1; i++)
{
   left[i] = (Edge*)malloc(sizeof(Edge));
}
for (int j = 0; j < n2; j++)
{
   right[j] = (Edge*)malloc(sizeof(Edge));
}
  
//fills both subarrays with half of edgeArray each
for (int i = 0; i < n1 ; i++)
{
   left[i] = edgeArray[start + i];
}
for (int j = 0 ; j < n2; j++)
{
   right[j] = edgeArray[(mid + 1) +j];
}

//travel integer for first subarray
int s1 = 0;
//travel integer for second subarray
int s2 = 0;
//travel integer for merged array
int t = start;

while ((s1 < n1) && (s2 < n2))
{
   //fills the merged array with the current smallest
   //value between two subarrays
   if ((left[s1]->getPrice()) <= (right[s2]->getPrice()))
   {
       edgeArray[t] = left[s1];
       s1++;
   }
   else
   {
       edgeArray[t] = right[s2];
       s2++;
   }
   t++;
}

//fills remainder of edgeArray slots
//with remaining subarray edges
while (s1 < n1)
{
   edgeArray[t] = left[s1];
   t++;
   s1++;
}
while (s2 < n2)
{
   edgeArray[t] = right[s2];
   t++;
   s2++;
}

//at the end, release the memory left and right subarrays
free(left);
free(right);
}


//*******************************************************************
//This function performs the Kruskal algorithm on the graph.
//*******************************************************************
void Graph::MST_Kruskal()
{
cout << "MST Kruskal Algorithm Result\n" << endl;
double totalWeight = 0.0;

//creates a set for each edge in flight path
for (int i = 0; i < V; i++)
{
   make_set(setOfCities[i]);
}

//sorts edges by non-decreasing weight
MergeSortEdges();

for (int j = 0; j < E; j++)
{
   City* aCity = (setOfEdges[j]->getCity1());
   City* bCity = (setOfEdges[j]->getCity2());

   //if the represenatives of each disjoint set
   //are not identical,a new path can be found
   //with minimum gain
   if (find_set(aCity) != find_set(bCity))
   {
       //the edge is added in MST set as
       //part of the path
       Union(aCity, bCity);

       //the weight of the new edge is added to the
       //path weight
       totalWeight = totalWeight + setOfEdges[j]->getPrice();
       setOfEdges[j]->printEdge();
   }
}

cout << "=================================================" << endl;
cout << "Total Price: " << totalWeight << endl;
}

Edge.h:

#include <iostream>
#include <iomanip>
#include <string>

using namespace std;

//City represents one vertex of the graph
struct City
{
   //atriutes for disjoint vertices
string cityName;
int rank;
struct City* parent;

//constructor
City(string name)
{
cityName = name;
rank = 0;
parent = NULL;
}
};

//class Edge represents one edge of the graph
class Edge
{
private:
struct City* city1;
struct City* city2;
double price;

   public:
   Edge(City* city1, City* city2, double price);
~Edge();
City* getCity1();
City* getCity2();
double getPrice();
void printEdge();
};

//constructor
Edge::Edge(City* newCity1, City* newCity2, double newPrice)
{
city1 = newCity1;
   city2 = newCity2;
   price = newPrice;
}

//Destructor
Edge::~Edge()
{
   city1 = NULL;
   city2 = NULL;
   price = 0;
}

//Accessor for city1
City* Edge::getCity1()
{
   return city1;
}

//Accessor for city2
City* Edge::getCity2()
{
   return city2;
}

//Accessor for price
double Edge::getPrice()
{
   return price;
}

//prints vertieces of edge in desired format
void Edge::printEdge()
{
cout << left;
cout << setw(15) << city1->cityName
<< setw(8) << "<--->"
<< setw(15) << city2->cityName
<< setw(3) << " = "
<< setw(8) << right << fixed << setprecision(2) << getPrice()
<< endl;
}